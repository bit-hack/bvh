#pragma once
#include <algorithm>
#include <array>
#include <cassert>


namespace bvh {

using index_t = int32_t;

static const index_t invalid_index = -1;

struct aabb_t {

  // lower bound
  float minx, miny;
  // upper bound
  float maxx, maxy;

  float area() const {
    const float dx = maxx - minx;
    const float dy = maxy - miny;
    return dx * dy;
  }

  // find the union of two aabb
  static aabb_t find_union(const aabb_t &a, const aabb_t &b) {
    return aabb_t{
      std::min<float>(a.minx, b.minx),
      std::min<float>(a.miny, b.miny),
      std::max<float>(a.maxx, b.maxx),
      std::max<float>(a.maxy, b.maxy)
    };
  }

  // grow the aabb evenly by an amount
  static aabb_t grow(const aabb_t &a, float amount) {
    return aabb_t{
      a.minx - amount,
      a.miny - amount,
      a.maxx + amount,
      a.maxy + amount
    };
  }

  // evaluate if this aabb contains another
  bool contains(const aabb_t &a) const {
    return a.minx >= minx && a.miny >= miny &&
           a.maxx <= maxx && a.maxy <= maxy;
  }
};

struct node_t {

  // for a leaf this will be a fat aabb and non terminal nodes will be regular
  struct aabb_t aabb;

  // left and right children
  std::array<index_t, 2> child;

  // index of the parent node
  index_t parent;

  // user provided data
  void *user_data;
};

struct bvh_t {

  bvh_t();

  // remove all nodes from the tree
  void clear();

  // create a new node in the tree
  index_t insert(const aabb_t &aabb, void *user_data);

  // remove a node from the tree
  void remove(index_t index);

  // move an existing node in the tree
  void move(index_t index, const aabb_t &aabb);

  // get a node from the tree
  const node_t &get(index_t index) const {
    return _nodes[index];
  }

  // this is the growth size for fat aabbs (they will be expanded by this)
  float growth;

protected:

  // sanity checks for the tree
  void _validate(index_t index);

  // insert 'node' into 'into' as a child
  // returns the node generated by the insertion which may be new or 'into'
  index_t _insert(index_t into, index_t node);

  // unlink this node from the tree but dont add it to the free list
  void _unlink(index_t index);

  // return true if a node is a leaf
  bool _is_leaf(index_t index) const;

  // access a node by index
  node_t &_get(index_t index) {
    assert(index != invalid_index);
    return _nodes[index];
  }

  // get a child
  node_t &_child(index_t index, int32_t child) {
    return _get(_get(index).child[child]);
  }

  // release all nodes
  void _free_all();

  // allocate a new node from the free list
  index_t _new_node();

  // add a node to the free list
  void _free_node(index_t index);

  static const uint32_t _max_nodes = 1024 * 32;

  // free and taken bvh nodes
  std::array<node_t, _max_nodes> _nodes;
  // start index of the free list
  index_t _free_list;
  // root node of the bvh
  index_t _root;
};

} // namespace bvh
